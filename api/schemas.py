# api/schemas.py

from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Any
import uuid
from datetime import datetime
from neo4j.time import DateTime as Neo4jDateTime  # Import for type checking


# This is a base model. It contains fields that are common to other models.
# It's a good practice to avoid repetition.
class SkillBase(BaseModel):
    name: str = Field(..., max_length=255)
    description: Optional[str] = None
    dependencies: List[str] = []


# This model is used when creating a new skill via the API.
# It inherits all fields from SkillBase.
class SkillCreate(SkillBase):
    pass


# This is the main model that will be used when reading data from the API.
# It includes fields that are generated by the database (id, created_at, etc.).
class Skill(SkillBase):
    id: uuid.UUID

    model_config = {"from_attributes": True}


class SkillUpdate(SkillBase):
    name: Optional[str] = None
    description: Optional[str] = None
    dependencies: Optional[List[str]] = None


class UserBase(BaseModel):
    email: str


# Properties to receive via API on creation
class UserCreate(UserBase):
    password: str


# Properties to return to client
class User(UserBase):
    id: int
    is_active: bool

    model_config = {"from_attributes": True}  # Allows populating from ORM objects


# ---- Token Schemas ----
class Token(BaseModel):
    access_token: str
    token_type: str


class UserPasswordChange(BaseModel):
    current_password: str
    new_password: str


# ---- Accomplishment Schemas ----
class Quest(BaseModel):
    id: uuid.UUID
    name: str
    description: str

class AccomplishmentCreate(BaseModel):
    user_email: str # Added user_email as it's needed for creating an accomplishment
    name: str
    description: str
    proof_url: Optional[str] = None
    quest_id: Optional[uuid.UUID] = None


class Accomplishment(AccomplishmentCreate):
    id: uuid.UUID
    timestamp: datetime

    model_config = {"from_attributes": True}

    @field_validator("timestamp", mode="before")
    @classmethod
    def convert_neo4j_datetime(cls, value: Any) -> Any:
        if isinstance(value, Neo4jDateTime):
            return value.to_native()
        return value
