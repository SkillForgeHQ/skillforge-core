# api/schemas.py

from pydantic import BaseModel, Field
from typing import List, Optional
import uuid


# This is a base model. It contains fields that are common to other models.
# It's a good practice to avoid repetition.
class SkillBase(BaseModel):
    name: str = Field(..., max_length=255)
    description: Optional[str] = None
    dependencies: List[str] = []


# This model is used when creating a new skill via the API.
# It inherits all fields from SkillBase.
class SkillCreate(SkillBase):
    pass


# This is the main model that will be used when reading data from the API.
# It includes fields that are generated by the database (id, created_at, etc.).
class Skill(SkillBase):
    id: uuid.UUID

    class Config:
        # This tells Pydantic to read the data even if it is not a dict,
        # but an ORM model (or any other arbitrary object with attributes).
        from_attributes = True


class SkillUpdate(SkillBase):
    name: Optional[str] = None
    description: Optional[str] = None
    dependencies: Optional[List[str]] = None


class UserBase(BaseModel):
    email: str


# Properties to receive via API on creation
class UserCreate(UserBase):
    password: str


# Properties to return to client
class User(UserBase):
    id: int
    is_active: bool

    class Config:
        from_attributes = True  # Allows populating from ORM objects


# ---- Token Schemas ----
class Token(BaseModel):
    access_token: str
    token_type: str


class MasteryCreate(BaseModel):
    level: int
    name: str
    description: str


class UserSkillMasteryCreate(BaseModel):
    skill_name: str
    mastery_level: int
