# api/tests/test_qa.py
import pytest # Added for @pytest.fixture
from fastapi.testclient import TestClient
# from api.main import app # Removed global app import
from api.security import create_access_token
from api.schemas import User # User is imported twice, will clean up later if distinct
from datetime import timedelta

# The autouse session-scoped fixture 'mock_neo4j_globally_session' in conftest.py
# should handle mocking Neo4jGraph before this module is imported.


# --- Helper class for mocking LLM results ---
class MockLLMResult:
    def __init__(self, content_value):
        self.content = content_value


# --- Mocking database for tests ---
from api.database import get_db
from unittest.mock import MagicMock

# Create a mock database session/connection
mock_db_connection = MagicMock()

# Configure the mock_db_connection for crud.get_user_by_email:
# crud.get_user_by_email calls: conn.execute(query).first()
# The token generated by get_test_user_token has "sub": "testuser"
# So, get_user_by_email will be called with email="testuser".
# We need it to return a valid User object.
from api.schemas import User  # Ensure User is imported if not already

test_user_for_db_mock = User(email="testuser", id=1, is_active=True)

mock_execute_result = MagicMock()
mock_execute_result.first.return_value = test_user_for_db_mock
mock_db_connection.execute.return_value = mock_execute_result


# Override for the get_db dependency
async def override_get_db():
    try:
        yield mock_db_connection
    finally:
        pass  # No actual closing needed for a mock

# app.dependency_overrides[get_db] = override_get_db # This was moved into the qa_app_client fixture
# --- End of database mocking ---

# client = TestClient(app) # Will be replaced by a fixture

@pytest.fixture
def qa_app_client():
    from api.main import create_app
    test_app = create_app()
    test_app.dependency_overrides[get_db] = override_get_db
    with TestClient(test_app) as client:
        yield client
    # Clear overrides if necessary, though for function scope it's usually fine
    test_app.dependency_overrides.clear()


def get_test_user_token():
    """Helper function to get a valid token for a test user."""
    test_user = User(email="test@example.com", id=1, is_active=True)
    # The username for the token subject can be hardcoded or derived
    # if it's consistently based on the email or id for test users.
    # For this test, "testuser" seems appropriate as it was used before.
    return create_access_token(
        data={"sub": "testuser"}, expires_delta=timedelta(minutes=15)
    )


def test_qa_endpoint_with_mocking(mocker, qa_app_client): # Added qa_app_client fixture
    """
    Tests the /qa/ endpoint by mocking the RAG chain.
    The 'mocker' fixture is provided by pytest-mock.
    """
    # Arrange: Set up the test conditions
    token = get_test_user_token()
    headers = {"Authorization": f"Bearer {token}"}
    test_question = "What is Python?"
    mock_answer = "This is a predictable, mocked answer about Python."

    # Mock the RAG chain. api.routers.qa.rag_chain is imported from api.ai.qa_service.rag_chain
    # We patch rag_chain in the module where it's defined (api.ai.qa_service)
    # so that api.routers.qa imports our mock.
    from unittest.mock import AsyncMock  # Ensure AsyncMock is imported

    # Configure the mock for api.ai.qa_service.rag_chain.ainvoke directly.
    # This will replace the 'ainvoke' method on the 'rag_chain' object
    # (wherever 'rag_chain' is within 'api.ai.qa_service') with an AsyncMock.
    # The AsyncMock is configured to return an instance of MockLLMResult.

    # Since api.ai.qa_service.rag_chain is now a MagicMock in TESTING_MODE,
    # we can directly import it and configure its ainvoke method.
    from api.ai import qa_service  # Import the module

    mock_llm_result = MockLLMResult(
        content_value=mock_answer
    )  # Uses module-level class
    # qa_service.rag_chain is already a MagicMock due to TESTING_MODE.
    # Configure its 'ainvoke' attribute to be an AsyncMock.
    qa_service.rag_chain.ainvoke = AsyncMock(return_value=mock_llm_result)

    # The Neo4jGraph mock below is redundant due to TESTING_MODE in api/database.py
    # and the conftest.py mock, but harmless to leave for now.
    # mocker.patch("api.database.Neo4jGraph", autospec=True) # Commenting out as it's not the primary fix here

    # Act: Call the API endpoint
    response = qa_app_client.post("/qa/", headers=headers, json={"question": test_question}) # Use qa_app_client

    # Assert: Check if the outcome is what we expect
    if response.status_code == 500:
        print("Response JSON for 500 error:", response.json())
    assert response.status_code == 200
    assert response.json() == {"answer": mock_answer}
